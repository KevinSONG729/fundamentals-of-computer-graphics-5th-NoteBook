# Texture Mapping

当试图复制现实世界的外观时，人们很快就会意识到几乎没有任何表面是没有特征的。所有的材料放入现实世界后，必定会很快布满痕迹、凹痕、污渍、划痕、指纹和污垢。

在计算机图形学中，我们把这种现象称为“spatially varying”的表面属性，也就是这种表面属性因地而异，但并没有改变这个表面的真正的形状。为了实现这些效果，各种建模和渲染系统都提供了一些纹理映射的方法：使用一张图像，被称作texture map 或者 texture image。或者就只是一个texture，去存储想要在表面上实现的细节，然后使用数学的方法将图像或者纹理**映射（mapping）**到物体表面上。

事实证明，一旦将图像映射到物体表面的机制存在，纹理映射还能做远远不止创造表面细节的事情，比如创造阴影和反射、提供照明、甚至可以定义出物体的形状。在复杂的交互程序中，纹理被用来存储各种数据，这些数据甚至与图片无关!

本章讨论使用纹理来表示表面细节、阴影和反射。虽然基本思想很简单，但是一些实践性的问题会让纹理的使用复杂化。首先，纹理很容易变形，所以这种映射会很有挑战性。其次，texture映射是一个resample的过程，就像重新缩放图像一样，正如在上一章提到，resample会带来混叠的问题。纹理映射和动画的一起使用很容易会带来混叠的问题，所以大部分纹理系统之所以复杂就是为了antialiasing。

## 11.1 Looking Up Texture Values

从简单的场景开始考虑——一个木质地板。我们希望用显示木地板木纹的图像控制地板的漫反射颜色。不管是光追还是光栅化（前者需要计算光线与物体交点的颜色，后者需要计算光栅化后的片段颜色），我们都需要知道在这个shading point上纹理的颜色，将其作为漫反射颜色，以便于使用第5章提到的Lambertian渲染模型。

为了得到这个颜色，着色器执行纹理查找：它在纹理图像的坐标系统中找出与shading point对应的location，并读取图像中该点的颜色，从而得到纹理样本。不同的像素对应图像中不同的位置，从而得到不同的颜色，代码如下：

<img src="picture2/image-20230210233737649.png" alt="image-20230210233737649" style="zoom:67%;" />

在这段代码中，着色器要求物体表面中的shadepoint能够提供坐标给texture查询，并且希望每个使用这个texture的表面都能够给出这个坐标。这带来了纹理映射的第一个关键要素：需要一个从表面映射到纹理的函数，使得我们可以很容易计算出每个像素。这被叫做纹理坐标函数（texture coordinate function）:

<img src="picture2/image-20230211010228162.png" alt="image-20230211010228162" style="zoom:67%;" />

上图左侧部分是viewing projection的过程，是将S映射到图像上的任何一个位置（这时候还未光栅化），右侧是texture mapping的过程，是将S映射到纹理图上。

纹理坐标函数为物体表面上的每一个点都提供了纹理坐标。从数学角度，这是一个从3D域S到2D域T的映射：

<img src="picture2/image-20230211010554868.png" alt="image-20230211010554868" style="zoom:67%;" />

集合T，通常被叫做“纹理空间”，只是一个包含纹理图像的矩形。普遍地，我们会使用单位正方形$(u,v)\in [0,1]^2$（在这本书中，我们使用$u$和$v$来表示纹理坐标）。这跟第8章提及的viewing projection（在本章被称作$\pi$过程）很相似，它将场景中的物体表面映射到了图像上的点。这两个过程都是3D to 2D的过程，也都是被渲染所需要的——一个需要知道怎么拿到纹理的值，一个需要知道怎么拿到图像像素的着色结果。但是这两个过程也有着重要的不同：$\pi$通常只包括投影变换和正交变换，而$\phi$可以有很多不同的形式；$\pi$只需要在整个场景中执行一次，而对于场景中不同的物体，可能需要执行不同的$\phi$。

有些人也许会感到惊讶，$\phi$是一个从表面到纹理图像的映射，而我们最终的目标是将纹理“贴”到物体表面上，但这就是我们需要的函数。

对于上述木制地板的情况，如果地板的z值恒定，并且长宽与xy轴都对齐，那么我们就可以简单地使用下面的mapping：
$$
u=ax;v=by,
$$
对于a、b的合适选择，可以为每个$(x,y,z)_{floor}$提供纹理坐标$(u,v)$，之后我们就可以使用纹理中位于这个位置的值，或者，**texel（texture image中的pixel）**，即最接近$(u,v)$的像素值来作为$(x,y)$处的纹理值。最终我们可以得到下图：

<img src="picture2/image-20230211012939211.png" alt="image-20230211012939211" style="zoom:67%;" />

但是这种方式是非常有限的，比如表面需要xy轴对齐，比如物体表面并不是平面，而是曲面，该怎么办？这让我们需要找到一些更好的方法来计算表面上的纹理坐标。

从上述的最简单的纹理映射方式还会造成另外一个问题，这个问题会在下述场景被戏剧性地暴露出来：从一个瞭望的角度（类似从很低的位置瞭望地平线，grazing angle）渲染一张低分辨率的图像，但是所用到的纹理是高分辨率的图像，或者是高对比度的内容。比如下图展示的：

<img src="picture2/image-20230211014511931.png" alt="image-20230211014511931" style="zoom:67%;" />

一个巨大的网格贴图，并且是以一种瞭望的角度。从中可以看到相当严重的混叠伪影（近处是清晰的网格，但是远处变成了波浪和闪烁），这特别像第10章resample的时候没有选择合适滤波器的结果。尽管这只是打印在书本上的一种极端情况，但是在动画中，这种情况哪怕只是出现一瞬也会严重影响观感。

现在我们看到了两个问题：

- 如何更好定义纹理坐标函数
- 如何在查询纹理时避免出现太多的混叠

这两个关注点是所有类型的纹理映射(tmap)的基础，将在11.2节和11.3节中讨论。一旦你理解了它们和它们的一些解决方案，你就理解了纹理映射。剩下的就是如何应用基本的纹理机制来实现各种不同的目的，这将在第11.4节中讨论。

## 11.2 Texture Coordinate Functions

设计一个好的纹理坐标函数$\phi$是获得良好纹理映射效果的关键要求。你可以认为这是决定如何变形一个平面，矩形图像，使它符合你想要绘制的3D表面。或者，对于物体表面，轻轻地将其压平，不让其起皱、撕裂或折叠，使其平躺在图像上。有时候，这很简单:也许3D曲面已经是一个平坦的矩形！在其他情况下，这是非常棘手的：3D形状可能非常复杂，就像角色身体的表面。

定义纹理坐标函数的问题对于计算机图形学来说并不新鲜。同样，制图师在设计覆盖地球表面的地图时也会遇到这样的问题。从曲面地球到平面地图的映射不可避免地会导致区域、角度和/或距离的失真，这很容易使地图产生误导。在过去的几个世纪里，已经提出了许多地图投影，它们都平衡了在纹理映射中面临的相同的棘手问题——在覆盖一个连续的大片区域的同时，尽量最小化各种各样的失真。

在一些应用程序中(一些例子在11.2.1节中)，使用特定的映射是有明确理由的。但在大多数情况下，设计纹理坐标映射是一项微妙的任务，需要平衡图中不同位置的失真点（有些失真是此消彼长的），熟练的建模师需要付出相当大的努力。

你可以用任何你能想到的方式定义$\phi$。但有几个彼此权衡的目标需要考虑：

- **双射性（Bijectivity）**。在大多数情况下，你希望$\phi$是双射的(参见章节2.1.1)，这样表面上的每个点映射到纹理空间中的一个不同的点。如果多个点映射到同一个纹理空间点，纹理中一个点的值将影响表面上的多个点。在您希望纹理在表面上重复的情况下(想想具有重复图案的壁纸或地毯)，有意地引入从表面点到纹理点的多对一映射是有意义的，但您不希望这种情况意外发生。
- **变形/失真尺度（Size distortion）**。纹理的尺度应该在整个表面上近似恒定。也就是说，表面上任何距离相同的紧密点都应该映射到纹理中距离相同的点。就函数$\phi$而言，$\phi$的导数的大小不宜变化太大。
- **变形/失真形状（Shape distortion）**。纹理不应该很扭曲。也就是说，在表面绘制的一个小圆应该映射到纹理空间中的一个合理的圆形，而不是一个极度压扁或拉长的形状。在$\phi$方面，$\phi$的导数在不同方向上不能相差太大。
- **连续性（Continuity）**。不应该有太多的接缝：表面上的相邻点应该映射到纹理中的相邻点。也就是说，φ应该是连续的或具有尽可能少的不连续。在大多数情况下，一些不连续是不可避免的，我们想把它们放在不显眼的位置。

通过参数方程(章节2.7.8)定义的曲面有一个固定的纹理坐标函数的选择：对定义曲面的函数求反，并使用表面的两个参数作为纹理坐标：
$$
f(p_1,p_2)=a \ point \ on \ the \ surface\\
\mapsto f^{-1}(a \ point \ on \ the \ surface)=(p_1,p_2)
$$
这些纹理坐标可能有也可能没有理想的属性，这取决于表面，但它们确实提供了映射。

但是对于隐式定义的曲面，或者只是由三角形网格定义的曲面，我们需要一些其他的方法来定义纹理坐标，而不依赖于现有的参数化。广义上讲，定义纹理坐标的两种方法是从几何上计算它们，从表面点的空间坐标，或者对于网格表面，在顶点存储纹理的值，并在整个表面上进行插值。让我们一个一个地看看这些选项。

### 11.2.1  Geometrically Determined Coordinates

几何确定的纹理坐标用于简单的形状或特殊情况，作为快速解决方案，或作为设计手工调整纹理坐标贴图的起点。我们将通过以下测试图像映射到物体表面来说明各种纹理坐标函数。图像中的数字可以让你从渲染的图像中读出近似的（u, v）坐标，而网格可以让你看到映射的失真程度：

<img src="picture2/image-20230211232039584.png" alt="image-20230211232039584" style="zoom:67%;" />

**平面投影（Planar Projection）**

很可能，从3D到2D的最简单映射是平行投影，与用于正交视图的映射相同。我们已经推导的用于视图的机制（第8.1节）可以直接用于定义几何坐标：正如正交视图归结为乘以矩阵并丢弃z分量一样，通过平面投影生成纹理坐标可以通过简单的矩阵乘法来完成：

<img src="picture2/image-20230211234606696.png" alt="image-20230211234606696" style="zoom:67%;" />

<img src="picture2/image-20230211234709121.png" alt="image-20230211234709121" style="zoom:67%;" />

其中纹理矩阵$M_t$表示仿射变换，星号表示我们不关心第三坐标中的结果。这对于大多数平坦的表面非常有效，表面法线没有太大的变化，并且通过取平均法线可以找到良好的投影方向。对于一个封闭图形来说，这种平面投影并不是单射的：前面和后面的点将映射到纹理空间中的同一点。

<img src="picture2/image-20230212004623974.png" alt="image-20230212004623974" style="zoom:67%;" />

可以看到，与投影平面相切的物体表面会发生极度扭曲，因为它们都被投影到纹理中非常相近的位置。通过简单地用透视投影代替正交投影，我们得到了投影纹理坐标：

<img src="picture2/image-20230212004917364.png" alt="image-20230212004917364" style="zoom:67%;" />

现在4×4矩阵$P_t$表示投影（不一定是仿射）变换，即最后一行可能不是$[0，0，0，1]$。

<img src="picture2/image-20230212005159547.png" alt="image-20230212005159547" style="zoom:67%;" />

投影纹理坐标在阴影映射技术（shadow mapping）中非常重要，如第11.4.4节所述。

**球形坐标（Spherical Coordinates）**

对于球体，纬度/经度参数化是熟悉且广泛使用的。它在极点附近会发生很多变形，这可能会导致困难，但它确实覆盖了球体，仅仅在一条纬度线上展现了不连续性。

形状大致为球形的曲面可以使用径向投影（radial projection）将曲面上的点映射到球体上的点：从球体中心穿过曲面上的一条线，然后找到与球体的交点。该交点的球面坐标就是曲面这个shading point的纹理坐标。

上述方法的另一种表示方式是，用球面坐标（ρ，θ，φ）表示表面点，然后丢弃ρ坐标，将θ和φ映射到范围[0，1]。该公式取决于球坐标计算的惯例；使用第2.7.8节的惯例：

<img src="picture2/image-20230212074629243.png" alt="image-20230212074629243" style="zoom:67%;" />

如果从中心点可以看到整个表面，则球坐标图在除极点以外的任何地方都是双射的（不是极点的地方都对应着一个截切圆，而极点处对应的是点）。它在两极附近继承了与球体上的经纬度图相同的失真。下图显示了一个对象，球坐标为其提供了合适的纹理坐标函数：

<img src="picture2/image-20230215010505936.png" alt="image-20230215010505936" style="zoom:67%;" />

对于上图模糊的球状物体，将每个点投影到以物体中心点为中心的球体上提供了单射映射，此处用于放置与地球图像相同的地图纹理。请注意，表面远离中心的区域会放大（表面点在纹理空间中挤在一起），而表面离中心较近的区域会缩小。（放大和缩小的比例由球坐标对应半径和点到物体中心距离的比例决定）。

**圆柱坐标（Cylindrical Coordinates）**

对于比较柱状的物体，将物体表面投影到圆柱上比球状更好：

<img src="picture2/image-20230215163827604.png" alt="image-20230215163827604" style="zoom:67%;" />

上图的左边采用的是球状投影，可以看到出现了大量的失真（中心小两端大），而右边的圆柱形投影在外表面产生了非常好的效果。类似于球面投影，这相当于转换为圆柱坐标并丢弃半径：

<img src="picture2/image-20230215164449138.png" alt="image-20230215164449138" style="zoom:67%;" />

圆柱坐标系是$(\rho,\theta,z)$，其中$\rho$是点M距离z轴的垂直距离，$\theta$是OM在x-y平面的投影与x轴正方向的夹角，$z$就是xyz坐标系中的z。xyz坐标系与圆柱坐标系之间的关系是：
$$
x=\rho cos\theta,\\
y=\rho sin\theta,\\
z=z.
$$
**立方体贴图（Cubemaps）**

使用球坐标来参数化球形或类球形形状会导致形状和极点附近区域的高度失真，这通常会导致可见的伪影，表明物体表面会有两个特殊点纹理出现问题。一种流行的替代方案更加统一失真比较少，但是代价是具有更多不连续性。这个想法是将物体表面投射到一个立方体上，而不是一个球体上，然后为立方体的六个面使用六个独立的正方形纹理。这六个面的纹理集合被称作立方体贴图，这会在所有的立方体边缘引入不连续性，但是它可以带来较低的形状和面积的失真。

计算Cubemaps纹理坐标比球面坐标更容易，因为投影到平面只需要一个除法——本质上与透视投影相同。比如对于投影到立方体+z面上的点：
$$
(x,y,z)\mapsto(\frac{x}{z},\frac{y}{z}).
$$
可以用等比的知识去理解，+z面上的z值是1，所以$(x,y,z)$对应着$(u,v,1)$。

Cubemaps的一大难点是如何在六个面上定义u-v的方向，任何定义都可以，但选择的定义会影响纹理的质量，因此标准化很重要。因为Cubemaps经常被用在从内部往外观察的场景中（比如11.4.5的环境贴图），所以通常的定义会指定u-v轴的朝向，从而在里面往外观察，每个面的u都在v的顺时针方向。OpenGL的定义是：

<img src="picture2/image-20230217014537510.png" alt="image-20230217014537510" style="zoom:67%;" />

<img src="picture2/image-20230217014555833.png" alt="image-20230217014555833" style="zoom:67%;" />

公式的下标代表着投影所对应的面。比如$\phi_{-x}$代表将点投影到x=1的面**（为什么不是x=-1?）** **（上面公式里的坐标符号也不能完全对上）**。可以通过坐标里最大的绝对值来判断应该把点投影到哪个面：比如$|x|$比$|y|$和$|z|$大，那么点就将被投影到+x或者-x面，进而如果x是正值，那么就是+x面，反之-x面，正如上图左图所示。

使用Cubemaps的纹理拥有六个正方形，它们通常是打包在一张图像中，就像立方体被打开了一样。

### 11.2.2 Interpolated Texture Coordinates

为了对三角形网格表面的纹理坐标函数进行更细粒度的控制，我们可以显式地存储每个顶点的纹理坐标，并使用重心插值在三角形上对它们进行插值(9.1.2节)。其他同样的属性（只要在三角上平滑变化）也可以这样操作，例如颜色、法线，甚至3D位置本身。

看只有一个三角形的例子：

<img src="picture2/image-20230217173342278.png" alt="image-20230217173342278" style="zoom:67%;" />

从左图可以看到，三个顶点的位置是$(0.2,0.2)、(0.8、0.4)、(0.4,0.8)$。正如上一节中几何确定的映射一样，我们通过提供从表面到纹理域的映射来控制纹理在曲面上的位置，而在这一节我们只需要确定顶点到纹理域的映射。一旦确定了顶点的映射，剩下的部分就由重心坐标插值来完成。

下图展示了在整个网格上可视化纹理坐标：

<img src="picture2/image-20230217174442282.png" alt="image-20230217174442282" style="zoom:67%;" />

可以看到，就是先确定顶点在纹理图像中的位置，然后简单地画出三角形就行了。这种可视化让我们看到纹理的哪部分对应于哪个三角形，这让我们很容易进行纹理坐标的评估和纹理映射代码的调试。

由顶点坐标定义的纹理坐标映射的质量取决于分配给顶点的坐标——也就是说，网格是如何在纹理空间中布局的。无论分配什么坐标，只要网格中的三角形顶点是共享的（12.1节），纹理坐标映射总是连续的，因为相邻的三角形在他们共享边的点上的纹理坐标是一致的。单射性保证了三角形在纹理空间中不会重叠——如果重叠，就代表一个在纹理空间中的点会出现在物体表面的多个地方。

当纹理空间中三角形的面积与其在3D中的面积成比例时，尺寸失真比较低。比如用连续的纹理映射函数表示一个人物的脸，通常会将鼻子压缩至纹理空间中一个相对较小的区域：

<img src="picture2/image-20230217180847201.png" alt="image-20230217180847201" style="zoom:67%;" />

虽然在3D空间中，鼻子上的三角形比脸颊上的小，但是在纹理空间中，尺度的比例更加极端（鼻子附近的纹理坐标顶点更小更密集），这在一定程度上扩大了鼻子的纹理，因为纹理上的一小部分区域，因为纹理坐标的密集，会占据物体表面的更大区域。同样的，比较前额和太阳穴，两者的三角形在3D区域中大小相似，但是太阳穴附近的三角形在纹理空间中更大，导致了太阳穴的纹理在3D中看起来更小。

同样的，当三角形的形状在3D和纹理空间中相似时，纹理的形状失真也会比较小。上面人脸的例子已经实现了相当低的失真，但是11.5中的球体在极点附近就有非常大的形状畸变：

<img src="picture2/image-20230218021406685.png" alt="image-20230218021406685" style="zoom:67%;" />

### 11.2.3 Tiling,Wrapping Modes,and Texture Transformations

允许纹理坐标超出纹理图像的范围通常是有用的。有时候，这恰巧是一个计算上的细节：对于一个本来精确落在纹理图像边界上的点，由于计算的舍入误差，这个点可能会落在图像稍外一点点。纹理坐标的映射机制必须保证这种情况不会发生取值的失败。

如果一个纹理只覆盖到表面的一部分，但是纹理坐标被设置成将整个表面映射到单位正方形，那么这时会有两个选项：（1）准备一个大部分是空白的纹理图像，内容只在其中的一个小区域。这需要一个超高分辨率的图像来获得相关区域的足够细节。（2）缩放所有纹理坐标，让他们覆盖更大的范围——比如$[-4.5,5.5]\times[-4.5,5.5]$，这时候单位正方形就位于这个更大范围的中心，同时大小是这个范围的1/10。有内容的区域这时同样被放大，位于单位正方形内，这时候对图像分辨率的要求就降低了。

对于上述第二种选项，当纹理查找位于单位正方形外，又位于纹理图像（就是上述的更大范围）内时，应该返回一个恒定的背景色。实现这一点的一种方法是设置一个背景色，当纹理查找在上述的范围内时，直接返回该背景色；如果纹理图像已经自带恒定的背景色（比如白色背景上的logo），则在扩展的纹理上自动计算背景色的方法是——返回距离该点最近的边缘点的纹理图像的颜色，这通常是对u-v坐标值进行clamp获得的。

有时，我们需要重复的图案，例如棋盘、瓷砖地板或砖墙。如果图案在矩形网格上重复，则创建具有相同数据的多个副本的图像将是浪费的。相反，当查找点离开纹理图像的右边缘时，我们可以使用环绕索引处理纹理图像外部的纹理查找，它环绕到左边缘。这是非常简单地使用像素坐标上的整数余数操作来处理的：

<img src="picture2/image-20230218213701802.png" alt="image-20230218213701802" style="zoom:67%;" />

这两种处理越界查找的方式之间的选择是通过从列表中选择一种环绕模式来指定的，该列表包括tiling、clamping以及两者的组合或变体。有了环绕模式，我们可以自由地将纹理想象成一个函数，它返回无限二维平面中任何点的颜色：

<img src="picture2/image-20230218214405911.png" alt="image-20230218214405911" style="zoom:67%;" />

当我们指定一个图像作为纹理时，环绕模式可以让我们知道如何利用这张有限的图像去定义上述的函数。在 11.5 节中，我们将看到程序纹理（procedural texture）可以自然地延伸到无限平面，因为它们不受有限图像数据的限制。由于两者在逻辑上都是无限的，因此这两种类型的纹理可以互换。

当调整纹理的比例和位置时，并不需要实际改变生成纹理坐标的函数，也不需要改变存储在网格顶点的纹理坐标值，只需要在纹理取值前对纹理坐标进行矩阵变换：

<img src="picture2/image-20230218220022488.png" alt="image-20230218220022488" style="zoom: 67%;" />

$\phi_{model}(x)$是纹理坐标函数。$M_T$是使用齐次坐标的3*3仿射或者投影矩阵，针对的是2D纹理坐标。这种变换有时候被限制在缩放/旋转两种，被使用纹理映射的大部分渲染器所支持。

### 11.2.4 Continuity and Seams

尽管低失真和连续性是纹理坐标函数中非常好的属性，但是不连续有时候在所难免。对于任何3D闭合曲面，拓扑学的一个基本结果是不存在一种双射函数将整个3D曲面映射到2D纹理图像中。所以我们必须引入接缝（seams）——在物体表面上的一条曲线，该曲线左右两侧的纹理坐标值会发生不连续的改变（跳变）。在除了接缝的地方，我们可以保证纹理映射的低失真。上面讨论的许多几何确定的纹理映射都包含了接缝：在球形和柱形坐标中，接缝是由atan2计算的角度从$-\pi$到$\pi$的地方；在cubemaps中，接缝就在立方体的边缘，在那里纹理映射会转换成不同面的uv坐标。

对于插值纹理坐标，接缝需要特别考虑，因为它不是自然发生的。我们之前观察到，在顶点共享的网格中，插值纹理坐标一定是连续的。但这意味这如果一个三角形跨越了一条接缝，其中一些顶点在一边，另一些顶点在另一边，插值机制会很愉快地提供一个连续的映射，但它可能会高度扭曲或者折叠，这使得其不是“注入式”的（不是单射）。下图在球面坐标映射的球体上说明了这个问题：

<img src="picture2/image-20230218021406685.png" alt="image-20230218021406685" style="zoom:67%;" />

在地球底部有一个三角形，它的一个顶点位于新西兰南岛的顶端，另一个顶点在北岛东北约400公里的太平洋上。一个明智的飞行员会在这些点之间飞行会飞越新西兰，但是路径从东经167度开始，到西经179度结束，所以线性插值选择了一条途中穿越南美洲的路线。这会导致纹理被压缩成跨越180经线的三角形带。解决方案是用等价的东经181度来标记第二个顶点（这是一个虚拟的点），但这只会把问题推给下一个三角形。（下一个三角形仍要跨越经线）

**要想在接缝附近创建一个干净的过渡过程，就要避免在接缝处共享纹理坐标。**穿过新西兰的三角形需要插值到经度181，而太平洋的下一个三角形需要从经度-179开始。为了做到这一点，我们复制接缝处的顶点：对于每个顶点，我们添加第二个具有等效经度的顶点（只不过相差360度，比如经度180的对面是经度-179，-179+360=181还是同一个点，但是这时不再跨越整张地图），并且接缝对面不使用相同的顶点。这个解决方法如上图的右半边所示，其中纹理空间最左边和最右边的顶点是重复的，具有相同的3D位置。

### 11.2.5 Texture coordinates in rendering systems

纹理用于各种渲染系统，虽然基本原理相同，但光线追踪和光栅化系统的细节不同。

纹理坐标是正在渲染的模型的一部分，场景描述需要包含足够的信息来定义它们是什么。大多数情况下，这意味着将纹理坐标存储为将与纹理一起使用的所有三角形网格的逐顶点属性。如果渲染系统直接支持网格以外的几何图元，这些图元通常具有预定义的纹理坐标（例如，球体上的纬度-经度坐标），可能为每个图元类型选择映射方案。

在光线追踪渲染器中，支持光线相交的每种表面类型不仅必须能够计算交点和表面法线，还必须能够计算交点的纹理坐标。与有关相交的其他信息一样，纹理坐标可以存储在命中记录（hit record）中（参见第 4.4.3 节）。在三角形网格表示的几何体的常见情况下，光线-三角形相交代码将通过重心插值从存储在顶点处的纹理坐标计算纹理坐标，对于其他类型的几何体，相交代码必须要直接地计算出纹理坐标。

在基于光栅化的系统中，三角形通常是唯一受支持的几何类型，因此所有表面都必须转换为这种形式。纹理坐标可以与模型一起读入（常见情况），或者对于在代码中生成的三角形网格，可以在创建网格时计算和存储它们。或者，对于可以从其他顶点数据计算的纹理坐标（例如，纹理坐标是从 3D 位置计算的），纹理坐标也可以在顶点着色器中计算并传递给光栅化器。纹理坐标然后由光栅化器进行插值，这样片段着色器的每次调用都有适合其片段的纹理坐标。

## 11.3 Antialiasing Texture Lookups



### 11.3.1 The Footprint of a pixel

### 11.3.2 Reconstruction

### 11.3.3 Mipmapping

### 11.3.4 Basic Texture Filtering with Mipmaps

### 11.3.5 Anisotropic Filtering

## 11.4 Applications of Texture Mapping

### 11.4.1 Controlling Shading Parameters

### 11.4.2 Normal Maps and Bump Maps

### 11.4.3  Displacement Maps

### 11.4.4 Shadow Maps

### 11.4.5 Environment Maps

## 11.5 Procedural 3D Textures

### 11.5.1 3D Stripe Textures

### 11.5.2 Solid Noise

### 11.5.3 Turbulence

## 11.6 Frequently Asked Questions



