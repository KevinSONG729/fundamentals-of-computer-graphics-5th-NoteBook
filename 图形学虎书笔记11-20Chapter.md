# Texture Mapping

当试图复制现实世界的外观时，人们很快就会意识到几乎没有任何表面是没有特征的。所有的材料放入现实世界后，必定会很快布满痕迹、凹痕、污渍、划痕、指纹和污垢。

在计算机图形学中，我们把这种现象称为“spatially varying”的表面属性，也就是这种表面属性因地而异，但并没有改变这个表面的真正的形状。为了实现这些效果，各种建模和渲染系统都提供了一些纹理映射的方法：使用一张图像，被称作texture map 或者 texture image。或者就只是一个texture，去存储想要在表面上实现的细节，然后使用数学的方法将图像或者纹理**映射（mapping）**到物体表面上。

事实证明，一旦将图像映射到物体表面的机制存在，纹理映射还能做远远不止创造表面细节的事情，比如创造阴影和反射、提供照明、甚至可以定义出物体的形状。在复杂的交互程序中，纹理被用来存储各种数据，这些数据甚至与图片无关!

本章讨论使用纹理来表示表面细节、阴影和反射。虽然基本思想很简单，但是一些实践性的问题会让纹理的使用复杂化。首先，纹理很容易变形，所以这种映射会很有挑战性。其次，texture映射是一个resample的过程，就像重新缩放图像一样，正如在上一章提到，resample会带来混叠的问题。纹理映射和动画的一起使用很容易会带来混叠的问题，所以大部分纹理系统之所以复杂就是为了antialiasing。

## 11.1 Looking Up Texture Values

从简单的场景开始考虑——一个木质地板。我们希望用显示木地板木纹的图像控制地板的漫反射颜色。不管是光追还是光栅化（前者需要计算光线与物体交点的颜色，后者需要计算光栅化后的片段颜色），我们都需要知道在这个shading point上纹理的颜色，将其作为漫反射颜色，以便于使用第5章提到的Lambertian渲染模型。

为了得到这个颜色，着色器执行纹理查找：它在纹理图像的坐标系统中找出与shading point对应的location，并读取图像中该点的颜色，从而得到纹理样本。不同的像素对应图像中不同的位置，从而得到不同的颜色，代码如下：

<img src="picture2/image-20230210233737649.png" alt="image-20230210233737649" style="zoom:67%;" />

在这段代码中，着色器要求物体表面中的shadepoint能够提供坐标给texture查询，并且希望每个使用这个texture的表面都能够给出这个坐标。这带来了纹理映射的第一个关键要素：需要一个从表面映射到纹理的函数，使得我们可以很容易计算出每个像素。这被叫做纹理坐标函数（texture coordinate function）:

<img src="picture2/image-20230211010228162.png" alt="image-20230211010228162" style="zoom:67%;" />

上图左侧部分是viewing projection的过程，是将S映射到图像上的任何一个位置（这时候还未光栅化），右侧是texture mapping的过程，是将S映射到纹理图上。

纹理坐标函数为物体表面上的每一个点都提供了纹理坐标。从数学角度，这是一个从3D域S到2D域T的映射：

<img src="picture2/image-20230211010554868.png" alt="image-20230211010554868" style="zoom:67%;" />

集合T，通常被叫做“纹理空间”，只是一个包含纹理图像的矩形。普遍地，我们会使用单位正方形$(u,v)\in [0,1]^2$（在这本书中，我们使用$u$和$v$来表示纹理坐标）。这跟第8章提及的viewing projection（在本章被称作$\pi$过程）很相似，它将场景中的物体表面映射到了图像上的点。这两个过程都是3D to 2D的过程，也都是被渲染所需要的——一个需要知道怎么拿到纹理的值，一个需要知道怎么拿到图像像素的着色结果。但是这两个过程也有着重要的不同：$\pi$通常只包括投影变换和正交变换，而$\phi$可以有很多不同的形式；$\pi$只需要在整个场景中执行一次，而对于场景中不同的物体，可能需要执行不同的$\phi$。

有些人也许会感到惊讶，$\phi$是一个从表面到纹理图像的映射，而我们最终的目标是将纹理“贴”到物体表面上，但这就是我们需要的函数。

对于上述木制地板的情况，如果地板的z值恒定，并且长宽与xy轴都对齐，那么我们就可以简单地使用下面的mapping：
$$
u=ax;v=by,
$$
对于a、b的合适选择，可以为每个$(x,y,z)_{floor}$提供纹理坐标$(u,v)$，之后我们就可以使用纹理中位于这个位置的值，或者，**texel（texture image中的pixel）**，即最接近$(u,v)$的像素值来作为$(x,y)$处的纹理值。最终我们可以得到下图：

<img src="picture2/image-20230211012939211.png" alt="image-20230211012939211" style="zoom:67%;" />

但是这种方式是非常有限的，比如表面需要xy轴对齐，比如物体表面并不是平面，而是曲面，该怎么办？这让我们需要找到一些更好的方法来计算表面上的纹理坐标。

从上述的最简单的纹理映射方式还会造成另外一个问题，这个问题会在下述场景被戏剧性地暴露出来：从一个瞭望的角度（类似从很低的位置瞭望地平线，grazing angle）渲染一张低分辨率的图像，但是所用到的纹理是高分辨率的图像，或者是高对比度的内容。比如下图展示的：

<img src="picture2/image-20230211014511931.png" alt="image-20230211014511931" style="zoom:67%;" />

一个巨大的网格贴图，并且是以一种瞭望的角度。从中可以看到相当严重的混叠伪影（近处是清晰的网格，但是远处变成了波浪和闪烁），这特别像第10章resample的时候没有选择合适滤波器的结果。尽管这只是打印在书本上的一种极端情况，但是在动画中，这种情况哪怕只是出现一瞬也会严重影响观感。

现在我们看到了两个问题：

- 如何更好定义纹理坐标函数
- 如何在查询纹理时避免出现太多的混叠

这两个关注点是所有类型的纹理映射(tmap)的基础，将在11.2节和11.3节中讨论。一旦你理解了它们和它们的一些解决方案，你就理解了纹理映射。剩下的就是如何应用基本的纹理机制来实现各种不同的目的，这将在第11.4节中讨论。

## 11.2 Texture Coordinate Functions

设计一个好的纹理坐标函数$\phi$是获得良好纹理映射效果的关键要求。你可以认为这是决定如何变形一个平面，矩形图像，使它符合你想要绘制的3D表面。或者，对于物体表面，轻轻地将其压平，不让其起皱、撕裂或折叠，使其平躺在图像上。有时候，这很简单:也许3D曲面已经是一个平坦的矩形！在其他情况下，这是非常棘手的：3D形状可能非常复杂，就像角色身体的表面。

定义纹理坐标函数的问题对于计算机图形学来说并不新鲜。同样，制图师在设计覆盖地球表面的地图时也会遇到这样的问题。从曲面地球到平面地图的映射不可避免地会导致区域、角度和/或距离的失真，这很容易使地图产生误导。在过去的几个世纪里，已经提出了许多地图投影，它们都平衡了在纹理映射中面临的相同的棘手问题——在覆盖一个连续的大片区域的同时，尽量最小化各种各样的失真。

在一些应用程序中(一些例子在11.2.1节中)，使用特定的映射是有明确理由的。但在大多数情况下，设计纹理坐标映射是一项微妙的任务，需要平衡图中不同位置的失真点（有些失真是此消彼长的），熟练的建模师需要付出相当大的努力。

你可以用任何你能想到的方式定义$\phi$。但有几个彼此权衡的目标需要考虑：

- **双射性（Bijectivity）**。在大多数情况下，你希望$\phi$是双射的(参见章节2.1.1)，这样表面上的每个点映射到纹理空间中的一个不同的点。如果多个点映射到同一个纹理空间点，纹理中一个点的值将影响表面上的多个点。在您希望纹理在表面上重复的情况下(想想具有重复图案的壁纸或地毯)，有意地引入从表面点到纹理点的多对一映射是有意义的，但您不希望这种情况意外发生。
- **变形/失真尺度（Size distortion）**。纹理的尺度应该在整个表面上近似恒定。也就是说，表面上任何距离相同的紧密点都应该映射到纹理中距离相同的点。就函数$\phi$而言，$\phi$的导数的大小不宜变化太大。
- **变形/失真形状（Shape distortion）**。纹理不应该很扭曲。也就是说，在表面绘制的一个小圆应该映射到纹理空间中的一个合理的圆形，而不是一个极度压扁或拉长的形状。在$\phi$方面，$\phi$的导数在不同方向上不能相差太大。
- **连续性（Continuity）**。不应该有太多的接缝：表面上的相邻点应该映射到纹理中的相邻点。也就是说，φ应该是连续的或具有尽可能少的不连续。在大多数情况下，一些不连续是不可避免的，我们想把它们放在不显眼的位置。

通过参数方程(章节2.7.8)定义的曲面有一个固定的纹理坐标函数的选择：对定义曲面的函数求反，并使用表面的两个参数作为纹理坐标：
$$
f(p_1,p_2)=a \ point \ on \ the \ surface\\
\mapsto f^{-1}(a \ point \ on \ the \ surface)=(p_1,p_2)
$$
这些纹理坐标可能有也可能没有理想的属性，这取决于表面，但它们确实提供了映射。

但是对于隐式定义的曲面，或者只是由三角形网格定义的曲面，我们需要一些其他的方法来定义纹理坐标，而不依赖于现有的参数化。广义上讲，定义纹理坐标的两种方法是从几何上计算它们，从表面点的空间坐标，或者对于网格表面，在顶点存储纹理的值，并在整个表面上进行插值。让我们一个一个地看看这些选项。

### 11.2.1  Geometrically Determined Coordinates

几何确定的纹理坐标用于简单的形状或特殊情况，作为快速解决方案，或作为设计手工调整纹理坐标贴图的起点。我们将通过以下测试图像映射到物体表面来说明各种纹理坐标函数。图像中的数字可以让你从渲染的图像中读出近似的（u, v）坐标，而网格可以让你看到映射的失真程度：

<img src="picture2/image-20230211232039584.png" alt="image-20230211232039584" style="zoom:67%;" />

**Planar Projection**（平面投影）

很可能，从3D到2D的最简单映射是平行投影，与用于正交视图的映射相同。我们已经推导的用于视图的机制（第8.1节）可以直接用于定义几何坐标：正如正交视图归结为乘以矩阵并丢弃z分量一样，通过平面投影生成纹理坐标可以通过简单的矩阵乘法来完成：

<img src="picture2/image-20230211234606696.png" alt="image-20230211234606696" style="zoom:67%;" />

<img src="picture2/image-20230211234709121.png" alt="image-20230211234709121" style="zoom:67%;" />

其中纹理矩阵$M_t$表示仿射变换，星号表示我们不关心第三坐标中的结果。这对于大多数平坦的表面非常有效，表面法线没有太大的变化，并且通过取平均法线可以找到良好的投影方向。对于一个封闭图形来说，这种平面投影并不是单射的：前面和后面的点将映射到纹理空间中的同一点。

<img src="picture2/image-20230212004623974.png" alt="image-20230212004623974" style="zoom:67%;" />

可以看到，与投影平面相切的物体表面会发生极度扭曲，因为它们都被投影到纹理中非常相近的位置。通过简单地用透视投影代替正交投影，我们得到了投影纹理坐标：

<img src="picture2/image-20230212004917364.png" alt="image-20230212004917364" style="zoom:67%;" />

现在4×4矩阵$P_t$表示投影（不一定是仿射）变换，即最后一行可能不是$[0，0，0，1]$。

<img src="picture2/image-20230212005159547.png" alt="image-20230212005159547" style="zoom:67%;" />

投影纹理坐标在阴影映射技术（shadow mapping）中非常重要，如第11.4.4节所述。



### 11.2.2 Interpolated Texture Coordinates

### 11.2.3 Tiling,Wrapping Modes,and Texture Transformations

### 11.2.4 Continuity and Seams

### 11.2.5 Texture coordinates in rendering systems

## 11.3 Antialiasing Texture Lookups

### 11.3.1 The Footprint of a pixel

### 11.3.2 Reconstruction

### 11.3.3 Mipmapping

### 11.3.4 Basic Texture Filtering with Mipmaps

### 11.3.5 Anisotropic Filtering

## 11.4 Applications of Texture Mapping

### 11.4.1 Controlling Shading Parameters

### 11.4.2 Normal Maps and Bump Maps

### 11.4.3  Displacement Maps

### 11.4.4 Shadow Maps

### 11.4.5 Environment Maps

## 11.5 Procedural 3D Textures

### 11.5.1 3D Stripe Textures

### 11.5.2 Solid Noise

### 11.5.3 Turbulence

## 11.6 Frequently Asked Questions



